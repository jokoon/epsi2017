PRESENTATION DES JEUX
Dans tous les jeux le joueur joue contre le CPU et doit tenter de le battre pour que son score soit validé.
Les jeux se déroulent en tour par tour.
Le CPU bénéficie d'un handicap puisqu'il est le second à jouer. Cependant il bénéficie par la suite d'algorithmes qui l'avantagent.
De fait, il peut rapidement revenir au score et battre le joueur.
Les jeux sont en anglais pour toucher un public plus large.

LIBRAIRIES
- les jeux sont créés en javascript natif sans utilisation de librairie ou framework spécifique.
- pour gérer le son j'utilise une librairie tierce libre de droit SoundJS de createJS https://createjs.com/soundjs 
  En effet, de manière native le son n'est pas bien géré en javascript. En particulier la possibilité de jouer plusieurs
  sons simultannéement, ce qui était problématique. A noter que certains navigateurs ne supportent que les fichiers OGG
  alors que d'autres ne supportent que les MP3.

ADAPTATION DES 3 JEUX pour le portail

1-jeu 1: changé le jeu principal pour qu'il y ait un système de points adapté à un classement par High Scores.
2-jeu 1: système de scoring avec moins d'amplitude (plus on dégomme d'adversaires en un seul coup et plus on marque de points exponentiellement)
3-jeu 1: gestion de random seed qui n'est pas supportée par défaut par javascript (j'ai trouvé une fonction sur un forum)
  ça permet avec un nombre entre 0 et 500000 de générer des îles différentes ou identiques
  Utile dans le cadre d'un défi, puisqu'une personne défiée pourrait avoir exactement la même île que la personne qui l'a défié
4-jeu 1: Il faut vaincre le CPU sinon le score retombe à 0 (il retombe à 0 même en cas d'égalité)
5-jeu 1:creation et gestion d'une présentation des règles et bouton start
6-jeu 2 et 3: creation et gestion d'un affichage d'écrans gagné et perdu à la fin
7-jeu 2: rendu le jeu plus facile. CPU trop difficile à battre. un choix sur 2 devient aléatoire.
8-jeu 2: modification de la phase wait pour que l'affichage se poursuive au debut et à la fin
9-jeu 2:creation et gestion d'une présentation des règles et bouton start
10-jeu 3:creation et gestion d'une présentation des règles et bouton start
11-jeu 1,2,3:creer un script externe
12-jeu 1,2,3:mettre l'appel du script à la fin du body

SUR LES 3 JEUX

13-appel des fichiers js externes à la fin du body

<script type="text/javascript" src="jeu01.js"></script>

14-fonction random pour gérer une random seed car ce n'est pas géré par javascript
limitation:la répartition de la nouvelle fonction de random n'est pas homogène
mais cela n'est pas problématique pour ce type d'utilisation

function my_random() {
	var xrand = Math.sin(random_seed++) * 10000;
	return xrand - Math.floor(xrand);
}

15-changement des 3 fichiers html pour en faire 3 php

16-recupération de paramètres en entrée

<?php
     $MODE_DEBUG=1;
     echo 'var URL_POST_SCORE="url_post_score.php?random='.rand(0,500000).'";';
     echo 'var URL_END="url_end.php";';
     echo 'var random_seed=2000;';
     echo 'var MODE_DEBUG='.$MODE_DEBUG.';';
     if($MODE_DEBUG===1){
        echo "alert('MODE_DEBUG:'+MODE_DEBUG);";
        echo "alert('POST:'+URL_POST_SCORE);";
        echo "alert('END:'+URL_END);";
        echo "alert('seed:'+random_seed);";
     }
?>

17-alerte des paramètres reçus pour débug d'integration si $MODE_DEBUG=true
sinon n'affiche pas les alertes

18-gestion des scores pour qu'ils soient postés à la fin ou 0 si le CPU gagne

19-affichage d'un message de fin

20-poste des scores en GET à la fin :
 
post_score(score);

function post_score(my_score){
   URL_POST=URL_POST_SCORE+"&score="+my_score;
   if(MODE_DEBUG==1){
      alert("POST:"+URL_POST);
   }
   var oReq = new XMLHttpRequest();
   oReq.addEventListener("load", callbackscore);
   oReq.open("GET", URL_POST);
   oReq.send();
}

21-alert de l'url appelée avec variables remplies à la fin pour debug d'intégration
POST:url_post_score.php?random=15747&score=0

22-récupération de la réponse du serveur

function callbackscore(){
  if(MODE_DEBUG==1){
     alert("callback:"+this.responseText);
  }
  setTimeout(leave_page,3000);
}

23-declanchement d'un setTimeout de 3 secondes pour passer la main

24-alert lorsque le setTimeout appelle son callback

function leave_page(){
  if(MODE_DEBUG==1){
      alert("quitte la page au bout de 3s");
  }
  location.replace(URL_END);
}

25-passage de main à URL_END et affichage d'une nouvelle page

26-tests unitaires pour valider les comportements perdant/gagnant et vérification des valeurs des variables passées

27-préparation des tests d'intégration